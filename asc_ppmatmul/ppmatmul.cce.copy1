#ifdef __CCE_KT_TEST__
#define __aicore__
#else
#define __aicore__ [aicore]
#endif
// CAmodel 不需要头文件
#ifndef CAMODEL

#include "kernel_operator.h"

#endif


using T_INPUT = float;
using T_OUTPUT = float;

constexpr int32_t L0AB_PINGPONG_BUFFER_LEN = 32 * 1024 / sizeof(T_INPUT);   // 32KB
constexpr int32_t L0C_PINGPONG_BUFFER_LEN = 64 * 1024 / sizeof(T_INPUT);    // 64KB
constexpr int32_t BLOCK_SIZE = 16;
constexpr int32_t C0_SIZE = 32 / sizeof(T_INPUT);                           
constexpr int32_t CUBE_MATRIX_SIZE = BLOCK_SIZE * C0_SIZE;                  // 16 * 8
constexpr int32_t L1_PINGPONG_BUFFER_LEN = 256 * 1024 / sizeof(T_INPUT);    // 256KB

__aicore__ __inline__ void load_matrix_zN(__cbuf__ float *dst, __gm__ float * src,
    int32_t R, int32_t C, int32_t valid_row, int32_t valid_col, size_t stride)
{
    constexpr int C0 = 32 / sizeof(float);
    constexpr int STRIDE_LIMIT = 65536;

    if(stride < STRIDE_LIMIT) {
        copy_gm_to_cbuf_multi_nd2nz_b32s(
            dst,
            src,
            static_cast<uint8_t>(0),            // sid
            static_cast<uint16_t>(1),           // ndNum
            static_cast<uint16_t>(valid_row),   // nValue
            static_cast<uint16_t>(valid_col),   // dValue
            static_cast<uint16_t>(0),           // srcNdMatrixStride
            static_cast<uint16_t>(stride),      // srcDValue
            static_cast<uint16_t>(R),           // dstNzC0Stride
            static_cast<uint16_t>(1),           // dstNzNStride
            static_cast<uint16_t>(0)           // dstNzMatrixStride
        );
    } else {
        for(int i = 0; i < valid_row; i++) {
            copy_gm_to_cbuf_multi_nd2nz_b32s(
                dst + i * C0,
                src + i * stride,
                static_cast<uint8_t>(0),            // sid
                static_cast<uint16_t>(1),           // ndNum
                static_cast<uint16_t>(1),           // nValue
                static_cast<uint16_t>(valid_col),   // dValue
                static_cast<uint16_t>(0),           // srcNdMatrixStride, unused
                static_cast<uint16_t>(0),           // srcDValue, unused
                static_cast<uint16_t>(R),           // dstNzC0Stride
                static_cast<uint16_t>(0),           // dstNzNStride, unused
                static_cast<uint16_t>(0)           // dstNzMatrixStride, unused
            );    
        }
    }
}

__aicore__ __inline__ void load_matrix_zZ(__cbuf__ float * dst, __gm__ float *src,
    int32_t R, int32_t C, int32_t valid_row, int32_t valid_col, size_t stride)
{
    constexpr int R0 = 16;
    constexpr int C0 = 32 / sizeof(float);
    constexpr int STRIDE_LIMIT = 65536;

    int64_t srcNdStride = R0 * stride;
    int64_t srcNStride = stride;
    if(srcNdStride < STRIDE_LIMIT) {
        int ndNum = valid_row / R0;
        int remains = valid_row % R0;
        if(ndNum > 0) {
            copy_gm_to_cbuf_multi_nd2nz_b32s(
                dst,
                src,
                static_cast<uint8_t>(0),            // sid
                static_cast<uint16_t>(ndNum),       // ndNum
                static_cast<uint16_t>(R0),          // nValue
                static_cast<uint16_t>(valid_col),   // dValue
                static_cast<uint16_t>(srcNdStride), // srcNdMatrixStride
                static_cast<uint16_t>(srcNStride),  // srcDValue
                static_cast<uint16_t>(R0),          // dstNzC0Stride
                static_cast<uint16_t>(1),           // dstNzNStride
                static_cast<uint16_t>(R0 * C)      // dstNzMatrixStride
            );
        }
        if(remains > 0){
            copy_gm_to_cbuf_multi_nd2nz_b32s(
                dst + ndNum * R0 * C,
                src + ndNum * R0 * stride,
                static_cast<uint8_t>(0),            // sid
                static_cast<uint16_t>(1),           // ndNum
                static_cast<uint16_t>(remains),     // nValue
                static_cast<uint16_t>(valid_col),   // dValue
                static_cast<uint16_t>(0),           // srcNdMatrixStride
                static_cast<uint16_t>(srcNStride),  // srcDValue
                static_cast<uint16_t>(R0),          // dstNzC0Stride
                static_cast<uint16_t>(1),           // dstNzNStride
                static_cast<uint16_t>(0)           // dstNzMatrixStride
            );
        }
    } else if (srcNStride < STRIDE_LIMIT) {
        int ndNum = valid_row / R0;
        int remains = valid_row % R0;
        for (int i = 0; i < ndNum; i++) {
            copy_gm_to_cbuf_multi_nd2nz_b32s(
                dst + i * R0 * C,
                src + i * R0 * stride,
                static_cast<uint8_t>(0),            // sid
                static_cast<uint16_t>(1),           // ndNum
                static_cast<uint16_t>(R0),          // nValue
                static_cast<uint16_t>(valid_col),   // dValue
                static_cast<uint16_t>(0),           // srcNdMatrixStride
                static_cast<uint16_t>(srcNStride),  // srcDValue
                static_cast<uint16_t>(R0),          // dstNzC0Stride
                static_cast<uint16_t>(1),           // dstNzNStride
                static_cast<uint16_t>(0)           // dstNzMatrixStride
            );
        }
        if(remains > 0) {
            copy_gm_to_cbuf_multi_nd2nz_b32s(
                dst + ndNum * R0 * C,
                src + ndNum * R0 * stride,
                static_cast<uint8_t>(0),            // sid
                static_cast<uint16_t>(1),           // ndNum
                static_cast<uint16_t>(remains),     // nValue
                static_cast<uint16_t>(valid_col),   // dValue
                static_cast<uint16_t>(0),           // srcNdMatrixStride
                static_cast<uint16_t>(srcNStride),  // srcDValue
                static_cast<uint16_t>(R0),          // dstNzC0Stride
                static_cast<uint16_t>(1),           // dstNzNStride
                static_cast<uint16_t>(0)           // dstNzMatrixStride
            );
        }
    } else {
        for(int i = 0; i < valid_row; i++) {
            int idxR0 = i / R0;
            int idxInR0 = i % R0;
            copy_gm_to_cbuf_multi_nd2nz_b32s(
                dst + idxR0 * R0 * C + idxR0 * C0,
                src + i * stride,
                static_cast<uint8_t>(0),            // sid
                static_cast<uint16_t>(1),           // ndNum
                static_cast<uint16_t>(1),           // nValue
                static_cast<uint16_t>(valid_col),   // dValue
                static_cast<uint16_t>(0),           // srcNdMatrixStride, unused
                static_cast<uint16_t>(0),           // srcDValue, unused
                static_cast<uint16_t>(R0),          // dstNzC0Stride
                static_cast<uint16_t>(0),           // dstNzNStride, unused
                static_cast<uint16_t>(0)           // dstNzMatrixStride, unused
            );
        }
    }
}

// CAmodel 需要将参数写入到tiling_para_gm中
#ifdef CAMODEL
extern "C" __global__ __aicore__ void dynamic_op_matmul_kernel(
    __gm__ T_INPUT * __restrict__ gm_a,
    __gm__ T_INPUT * __restrict__ gm_b,
    __gm__ T_OUTPUT * __restrict__ gm_c,
    __gm__ uint32_t * __restrict__ tiling_para_gm)
#else
extern "C" __global__ __aicore__ void dynamic_op_matmul_kernel(
    __gm__ T_INPUT * __restrict__ gm_a,
    __gm__ T_INPUT * __restrict__ gm_b,
    __gm__ T_OUTPUT * __restrict__ gm_c,
    int32_t batchSize,
    int32_t trans_a,
    int32_t trans_b,
    int32_t M,
    int32_t N,
    int32_t K,
    int32_t lda,
    int32_t ldb,
    int32_t ldc,
    int M0,
    int N0,
    int K0)
#endif
{
    set_padding(0);
    set_atomic_none();
    uint64_t config = 0x1;
    set_nd_para(config);
// CAmodel 从tiling_para_gm解析出参数
#ifdef CAMODEL
    // get tiling args
    auto tiling_para = reinterpret_cast<__gm__ int32_t *>(tiling_para_gm);
    int32_t batchSize = tiling_para[0];
    int32_t trans_a = tiling_para[1];
    int32_t trans_b = tiling_para[2];
    int32_t M = tiling_para[3];
    int32_t N = tiling_para[4];
    int32_t K = tiling_para[5];
    int32_t lda = tiling_para[6];
    int32_t ldb = tiling_para[7];
    int32_t ldc = tiling_para[8];
    int32_t M0 = tiling_para[9];
    int32_t N0 = tiling_para[10];
    int32_t K0 = tiling_para[11];
#endif

    auto l1_base_a = reinterpret_cast<__cbuf__ T_INPUT *>((uintptr_t)0);            // 128 KB
    auto l1_base_b = reinterpret_cast<__cbuf__ T_INPUT *>((uintptr_t)(128 * 1024)); // 128 KB

    auto l0a_base = reinterpret_cast<__ca__ T_INPUT *>((uintptr_t)0);
    auto l0b_base = reinterpret_cast<__cb__ T_INPUT *>((uintptr_t)0);
    auto l0c_base = reinterpret_cast<__cc__ float *>((uintptr_t)0);
    // auto l0c_buf = reinterpret_cast<__cc__ float *>((uintptr_t)0);

    int32_t m_loop = (M + M0 - 1) / M0;
    int32_t n_loop = (N + N0 - 1) / N0;
    int32_t k_loop = (K + K0 - 1) / K0;
    int32_t loop = batchSize * m_loop * n_loop;

    int32_t l0c_ping_flag = 1;

    int32_t ping_flag = 1;

    set_flag(PIPE_FIX, PIPE_M, EVENT_ID0);
    set_flag(PIPE_FIX, PIPE_M, EVENT_ID1);

    set_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID0);
    set_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID1);
    set_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID2);
    set_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID3);
    
    set_flag(PIPE_M, PIPE_MTE1, EVENT_ID0);
    set_flag(PIPE_M, PIPE_MTE1, EVENT_ID1);

    for (int32_t loop_idx = 0; loop_idx < loop; loop_idx++) {
        if (loop_idx % get_block_num() != get_block_idx()) {
            continue;
        }

        auto l0c_buf = l0c_ping_flag ? l0c_base + L0C_PINGPONG_BUFFER_LEN : l0c_base;
        auto l0c_EVENT_ID = l0c_ping_flag ? EVENT_ID0 : EVENT_ID1;

        int64_t batch_idx = loop_idx / (m_loop * n_loop);
        int64_t in_batch_idx = loop_idx % (m_loop * n_loop);
        int64_t m_idx;
        int64_t n_idx;

        constexpr int N_COL = 16;
        int tile_block_loop = (n_loop + N_COL - 1) / N_COL;
        int tile_block_idx = in_batch_idx / (N_COL * m_loop);
        int in_tile_block_idx = in_batch_idx % (N_COL * m_loop);
        int n_col = N_COL;
        if(tile_block_idx == tile_block_loop - 1) {
            n_col = n_loop - N_COL * tile_block_idx;
        }
        m_idx = in_tile_block_idx / n_col;
        n_idx = tile_block_idx * N_COL + in_tile_block_idx % n_col;
        // m_idx = in_batch_idx / n_loop;
        // n_idx = in_batch_idx % n_loop;

        int64_t offset_a, offset_b;
        int64_t offset_c = batch_idx * M * ldc + m_idx * M0 * ldc + n_idx * N0;
        int32_t m_actual = (m_idx == (m_loop - 1)) ? (M - m_idx * M0) : M0;
        int32_t n_actual = (n_idx == (n_loop - 1)) ? (N - n_idx * N0) : N0;
        int32_t m_round = (m_actual + 15) / 16 * 16;
        int32_t n_round = (n_actual + 15) / 16 * 16;

        int32_t mn_max = m_round > n_round ? m_round : n_round;
        int32_t k_part_len = L0AB_PINGPONG_BUFFER_LEN / mn_max / 16 * 16;

        for (int32_t k_idx = 0; k_idx < k_loop; k_idx++) {
            if(trans_a) {
                offset_a = batch_idx * lda * K + k_idx * K0 * lda + m_idx * M0;
            } else {
                offset_a = batch_idx * M * lda + m_idx * M0 * lda + k_idx * K0;
            }

            if(trans_b) {
                offset_b = batch_idx * ldb * N + n_idx * N0 * ldb + k_idx * K0;
            } else {
                offset_b = batch_idx * K * ldb + k_idx * K0 * ldb + n_idx * N0;
            }

            int32_t k_actual = (k_idx == (k_loop - 1)) ? (K - k_idx * K0) : K0;
            int32_t k_round = (k_actual + 15) / 16 * 16;
            int32_t k_part_loop = (k_actual + k_part_len - 1) / k_part_len;

            auto l1_buf_a = ping_flag ? l1_base_a : l1_base_a + L1_PINGPONG_BUFFER_LEN;
            auto l1_buf_b = ping_flag ? l1_base_b : l1_base_b + L1_PINGPONG_BUFFER_LEN;
            auto event_id = ping_flag ? EVENT_ID0 : EVENT_ID1;

            // *** load matrix A to L1
            wait_flag(PIPE_MTE1, PIPE_MTE2, event_id);
            if (trans_a) {
                if(M == 1) {
                    copy_gm_to_cbuf(
                        l1_buf_a,
                        gm_a + offset_a,
                        0,                                  // sid
                        1,                                  // nBurst
                        (k_actual + C0_SIZE - 1) / C0_SIZE, // lenBurst
                        0,                                  // srcGap
                        0,                                  // dstGap
                        PAD_NONE                            // padMode
                    );
                } else {
                    load_matrix_zZ(l1_buf_a, gm_a + offset_a, K0, M0, k_actual, m_actual, lda);
                }
            } else {
                if (m_actual == 1) {
                    copy_gm_to_cbuf(
                        l1_buf_a,
                        gm_a + offset_a,
                        0,                                  // sid
                        1,                                  // nBurst
                        (k_actual + C0_SIZE - 1) / C0_SIZE, // lenBurst
                        0,                                  // srcGap
                        0,                                  // dstGap
                        PAD_NONE                            // padMode
                    );
                } else {
                    load_matrix_zN(l1_buf_a, gm_a + offset_a, M0, K0, m_actual, k_actual, lda);
                    // if (k_part_loop == 1) {
                    //     load_matrix_zZ(l1_buf_a, gm_a + offset_a, M0, K0, m_actual, k_actual, K);
                    // } else {
                    //     load_matrix_zN(l1_buf_a, gm_a + offset_a, M0, K0, m_actual, k_actual, K);
                    // }
                }
            }
            set_flag(PIPE_MTE2, PIPE_MTE1, event_id);
            

            // *** load matrix B to L1
            wait_flag(PIPE_MTE1, PIPE_MTE2, event_id + 2);
            if (trans_b) {
                load_matrix_zN(l1_buf_b, gm_b + offset_b, N0, K0, n_actual, k_actual, ldb);
            } else {
                load_matrix_zZ(l1_buf_b, gm_b + offset_b, K0, N0, k_actual, n_actual, ldb);
            }

            set_flag(PIPE_MTE2, PIPE_MTE1, event_id + 2);

            for (int k_part_idx = 0; k_part_idx < k_part_loop; k_part_idx++) {
                int32_t k0_round = (k_part_idx < k_part_loop - 1) ? k_part_len : k_round - k_part_idx * k_part_len;
                int32_t k0_actual = (k_part_idx < k_part_loop - 1) ? k_part_len : k_actual - k_part_idx * k_part_len;
            
                auto mte1_mad_ping_flag = 1 - k_part_idx % 2;
                auto mte1_mad_event_id = mte1_mad_ping_flag ? EVENT_ID0 : EVENT_ID1;
                auto l0a_buf = l0a_base + (k_part_idx % 2) * L0AB_PINGPONG_BUFFER_LEN;
                auto l0b_buf = l0b_base + (k_part_idx % 2) * L0AB_PINGPONG_BUFFER_LEN;
            
                // *** load matrix A from L1 to L0A
                if (k_part_idx == 0) {
                    wait_flag(PIPE_MTE2, PIPE_MTE1, event_id);
                }
                wait_flag(PIPE_M, PIPE_MTE1, mte1_mad_event_id);
                if (M == 1 || m_actual == 1 && !trans_a) {
                    load_cbuf_to_ca(
                        l0a_buf,
                        l1_buf_a + k_part_idx * k_part_len,
                        0,                                                      // baseIdx
                        (k0_round + CUBE_MATRIX_SIZE - 1) / CUBE_MATRIX_SIZE,   // repeat
                        1,                                                      // srcStride
                        0,                                                      // dstStride
                        0,                                                      // sid
                        false,                                                  // transpose
                        inc                                                     // addr_cal_mode_t
                    );
                } else {
                    if (trans_a) {
                        auto l1_src_a = l1_buf_a + k_part_idx * k_part_len * M0;
                        for (int i = 0; i < m_round / BLOCK_SIZE; i++) {
                            load_cbuf_to_ca_transpose(
                                l0a_buf + i * k0_round * BLOCK_SIZE,
                                l1_src_a + i * 2 * CUBE_MATRIX_SIZE,
                                0,                              // indexID
                                k0_round / BLOCK_SIZE,          // repeat
                                M0 / BLOCK_SIZE,                // srcStride
                                1,                              // dstStride
                                inc,                            // addrmode
                                0                               // dstFracStride
                            );
                        }
                    } else {
                        // auto l1_src_a = l1_buf_a + k_part_idx * k_part_len * BLOCK_SIZE;
                        // for (int i = 0; i < m_round / BLOCK_SIZE; i++) {
                        //     load_cbuf_to_ca(
                        //         l0a_buf + i * k0_round * BLOCK_SIZE,
                        //         l1_src_a + i * BLOCK_SIZE * K0,
                        //         0,                              // baseIdx
                        //         k0_round / C0_SIZE,             // repeat
                        //         1,                              // srcStride
                        //         0,                              // dstStride
                        //         0,                              // sid
                        //         false,                          // transpose
                        //         inc                             // addr_cal_mode_t
                        //     );
                        // }

                        auto l1_src_a = l1_buf_a + k_part_idx * k_part_len * M0;
                        for (int i = 0; i < m_round / BLOCK_SIZE; i++) {
                            load_cbuf_to_ca(
                                l0a_buf + i * k0_round * BLOCK_SIZE,
                                l1_src_a + i * CUBE_MATRIX_SIZE,
                                0,                              // baseIdx
                                k0_round / C0_SIZE,             // repeat
                                M0 / BLOCK_SIZE,                              // srcStride
                                0,                              // dstStride
                                0,                              // sid
                                false,                          // transpose
                                inc                             // addr_cal_mode_t
                            );
                        }

                        // if (k_part_loop == 1) {
                        //     load_cbuf_to_ca(
                        //         l0a_buf,
                        //         l1_buf_a,
                        //         0,                                    // baseIdx
                        //         k0_round / C0_SIZE * M0 / BLOCK_SIZE, // repeat
                        //         1,                                    // srcStride
                        //         0,                                    // dstStride
                        //         0,                                    // sid
                        //         false,                                // transpose
                        //         inc                                   // addr_cal_mode_t
                        //     );
                        // } else {
                        //     auto l1_src_a = l1_buf_a + k_part_idx * M0 * k0_round;
                        //     for (int i = 0; i < m_round / BLOCK_SIZE; i++) {
                        //         load_cbuf_to_ca(
                        //             l0a_buf + i * k0_round * BLOCK_SIZE,
                        //             l1_src_a + i * CUBE_MATRIX_SIZE,
                        //             0,                              // baseIdx
                        //             k0_round / C0_SIZE,             // repeat
                        //             M0 / BLOCK_SIZE,                              // srcStride
                        //             0,                              // dstStride
                        //             0,                              // sid
                        //             false,                          // transpose
                        //             inc                             // addr_cal_mode_t
                        //         );
                        //     }
                        // }
                    }
                }
                if (k_part_idx == k_part_loop - 1) {
                    set_flag(PIPE_MTE1, PIPE_MTE2, event_id);
                }

                // *** load matrix B from L1 to L0B
                if (k_part_idx == 0) {
                    wait_flag(PIPE_MTE2, PIPE_MTE1, event_id + 2);
                }
                if (trans_b) {
                    // TODO
                    // auto l1_src_b = l1_buf_b + k_part_idx * k_part_len * BLOCK_SIZE;
                    // for (int i = 0; i < n_round / C0_SIZE; i++) {
                    //     load_cbuf_to_cb(
                    //         l0b_buf + i * K0 * C0_SIZE,
                    //         l1_src_b + i * CUBE_MATRIX_SIZE,
                    //         0,                              // baseIdx
                    //         k0_round / BLOCK_SIZE,          // repeat
                    //         N0 / C0_SIZE,                   // srcStride
                    //         0,                              // dstStride
                    //         0,                              // sid
                    //         false,                          // transpose
                    //         inc                             // addrmode
                    //     );
                    // }
                    auto l1_src_b = l1_buf_b + k_part_idx * k_part_len * N0;
                    for (int i = 0; i < k0_round / C0_SIZE; i++) {
                        load_cbuf_to_cb(
                            l0b_buf + i * n_round * C0_SIZE,
                            l1_src_b + i * C0_SIZE * N0,
                            0,                              // indexID
                            n_round / BLOCK_SIZE,           // repeat
                            1,                              // srcStride
                            0,                              // dstStride
                            0,                              // sid
                            false,                          // transpose
                            inc                             // addrmode
                        );
                    }
                } else {
                    auto l1_src_b = l1_buf_b + k_part_idx * k_part_len * N0;
                    for (int i = 0; i < n_round / BLOCK_SIZE; i++) {
                        load_cbuf_to_cb_transpose(
                            l0b_buf + i * CUBE_MATRIX_SIZE,
                            l1_src_b + i * 2 * CUBE_MATRIX_SIZE,
                            0,                              // indexID
                            k0_round / BLOCK_SIZE,          // repeat
                            N0 / BLOCK_SIZE,                // srcStride
                            2 * n_round / BLOCK_SIZE - 1,   // dstStride
                            inc,                            // addrmode
                            n_round / BLOCK_SIZE - 1        // dstFracStride
                        );
                    }
                    // auto l1_src_b = l1_buf_b + k_part_idx * k_part_len * N0;
                    // for (int i = 0; i < n_round / BLOCK_SIZE; i++) {
                    //     load_cbuf_to_cb_transpose(
                    //         l0b_buf + i * CUBE_MATRIX_SIZE,
                    //         l1_src_b + i * 2 * CUBE_MATRIX_SIZE,
                    //         0,                              // indexID
                    //         k0_round / BLOCK_SIZE,          // repeat
                    //         N0 / BLOCK_SIZE,                // srcStride
                    //         2 * n_round / BLOCK_SIZE - 1,   // dstStride
                    //         inc,                            // addrmode
                    //         n_round / BLOCK_SIZE - 1        // dstFracStride
                    //     );
                    // }
                }
                if (k_part_idx == k_part_loop - 1) {
                    set_flag(PIPE_MTE1, PIPE_MTE2, event_id + 2);
                }

                set_flag(PIPE_MTE1, PIPE_M, mte1_mad_event_id);
                wait_flag(PIPE_MTE1, PIPE_M, mte1_mad_event_id);

                bool init_c = (k_idx == 0 && k_part_idx == 0);
                if (init_c) {
                    wait_flag(PIPE_FIX, PIPE_M, l0c_EVENT_ID);
                }

                if (M != 1 && m_actual == 1 && trans_a) {
                    mad(l0c_buf,
                        l0a_buf,
                        l0b_buf,
                        16,                             // m
                        k0_actual,                      // k
                        n_actual,                       // n
                        0,                              // unitFlag
                        1,                              // kDirectionAlign
                        0,                              // cmatrixSource
                        init_c                          // cmatrixInitVal
                    );
                } else {
                    mad(l0c_buf,
                        l0a_buf,
                        l0b_buf,
                        m_actual,                       // m
                        k0_actual,                      // k
                        n_actual,                       // n
                        0,                              // unitFlag
                        1,                              // kDirectionAlign
                        0,                              // cmatrixSource
                        init_c                          // cmatrixInitVal
                    );
                }
                
                pipe_barrier(PIPE_M);
                set_flag(PIPE_M, PIPE_MTE1, mte1_mad_event_id);
            }
            ping_flag = 1 - ping_flag;
        }

        set_flag(PIPE_M, PIPE_FIX, EVENT_ID0);
        wait_flag(PIPE_M, PIPE_FIX, EVENT_ID0);

        // copy from L0C to gm
        // 修改代码，将矩阵乘结果的dst stride修改为K，之前是N。修改为K的原因是因为右矩阵是一个方阵。
        // 完整的DFT的结果就是BatchSize * K（这个K表示的是矩阵乘的K参数，这个K参数等于输入参数n）
        copy_matrix_cc_to_gm(
            gm_c + offset_c,
            l0c_buf,
            0,          // sid
            n_actual,   // NSize
            m_actual,   // MSize
            ldc,          // dstStride_dst_D
            m_round,    // srcStride
            0,          // UnitFlagMode
            NoQuant,    // QuantPRE
            0,          // ReLUPRE
            false,      // channelSplit
            true        // NZ2ND_EN
        );

        l0c_ping_flag = 1 - l0c_ping_flag;

        set_flag(PIPE_FIX, PIPE_M, l0c_EVENT_ID);
    }


    wait_flag(PIPE_M, PIPE_MTE1, EVENT_ID0);
    wait_flag(PIPE_M, PIPE_MTE1, EVENT_ID1);

    wait_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID0);
    wait_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID1);
    wait_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID2);
    wait_flag(PIPE_MTE1, PIPE_MTE2, EVENT_ID3);

    wait_flag(PIPE_FIX, PIPE_M, EVENT_ID0);
    wait_flag(PIPE_FIX, PIPE_M, EVENT_ID1);

    pipe_barrier(PIPE_ALL);
}

#ifndef CAMODEL
void asc_ppmatmul(
    void* stream,
    __gm__ T_INPUT * __restrict__ gm_A,
    __gm__ T_INPUT * __restrict__ gm_B,
    __gm__ T_OUTPUT * __restrict__ gm_C,
    int32_t batchSize,
    int trans_a,
    int trans_b,
    int32_t M,
    int32_t N,
    int32_t K,
    int32_t lda,
    int32_t ldb,
    int32_t ldc
) {
    int32_t M_round = (M + 16 - 1) / 16 * 16;
    int32_t N_round = (N + 16 - 1) / 16 * 16;
    int32_t K_round = (K + 16 - 1) / 16 * 16;
    int32_t M0 = M_round < 128 ? M_round : 128;
    int32_t N0 = N_round < 128 ? N_round : 128;
    int32_t K0 = K_round < 128 ? K_round : 128;
    int32_t M0_tile_num_of_M = (M + M0 - 1) / M0;
    int32_t N0_tile_num_of_N = (N + N0 - 1) / N0;
    int32_t blockDim = M0_tile_num_of_M * N0_tile_num_of_N;
    blockDim = blockDim < 20 ? blockDim : 20;
    dynamic_op_matmul_kernel<<<blockDim, nullptr, stream>>>(
        gm_A,
        gm_B,
        gm_C,
        batchSize,
        trans_a,
        trans_b,
        M,
        N,
        K,
        lda,
        ldb,
        ldc,
        M0,
        N0,
        K0);
}
#endif
